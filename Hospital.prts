//I think we only simulate up to 60 minutes.... otherwise too long

#import "PAT.Lib.List";

#define N 6;
#define MaxWaiting 10;
#define ConsultTime 20;
#define RegisterTime 5;
#define openHour 60;
#define MaxQueueLength 5;
#define StockLowerBound 10;
var ServePatient = 0;
var AngryPatient = 0;
var FreeDoctor = 3;
var Inspector = 1;
var MedicineStock = 100;
var student = 1;
var worker = 2;
var elderly = 3;

var<List> NormalCounter;
var<List> SpecialCounter; 
var<List> ConsultQueue;
var<List> InspectQueue;

//Arrive(i) = pcase{
//				1: Wait[i*5]
//				1: Wait[i*10]
//				1: Wait[i*20]
//				};

Arrive(i) = atomic{     pcase {
						4: SetComingPeopleType(i); NormalRegistration(i)
						1: SetComingPeopleType(i); SpecialRegistration(i)
						}
			};

SetComingPeopleType(i) = atomic{
						pcase {
							1: SetStudentComingTime()
							2: SetWorkerComingTime()
							3: SetElderlyComingTime()
						}
			};
SetStudentComingTime() = atomic {
						pcase {
						1: Wait[5]
						1: Wait[10]
						1: Wait[15]
						1: Wait[20]
						3: Wait[25]
						3: Wait[30]
						3: Wait[35]
						3: Wait[40]
						1: Wait[45]
						1: Wait[50]
						1: Wait[55]
						1: Wait[60]
						}
};

SetWorkerComingTime() = atomic {
						pcase {
						1: Wait[5]
						1: Wait[10]
						1: Wait[15]
						1: Wait[20]
						1: Wait[25]
						1: Wait[30]
						1: Wait[35]
						1: Wait[40]
						3: Wait[45]
						3: Wait[50]
						3: Wait[55]
						3: Wait[60]
						}
};

SetElderlyComingTime() = atomic {
						pcase {
						3: Wait[5]
						3: Wait[10]
						3: Wait[15]
						1: Wait[20]
						1: Wait[25]
						1: Wait[30]
						1: Wait[35]
						1: Wait[40]
						1: Wait[45]
						3: Wait[50]
						3: Wait[55]
						3: Wait[60]
						}
};			

NormalRegistration(i) = if (NormalCounter.Count() > MaxQueueLength) {
							atomic{AngryLeave.i{AngryPatient ++} -> Skip}
						} else {
							QueueUp.i{NormalCounter.Add(i)} -> ((atomic{[NormalCounter.Count()>0 && NormalCounter.Get(0) == i]Register.i ->
							Wait[RegisterTime]; tau{NormalCounter.RemoveAt(0)} -> Consultation(i)}) timeout[MaxWaiting] 
							(AngryLeave.i{AngryPatient ++;NormalCounter.Remove(i)} -> Skip))
						};

SpecialRegistration(i) = if (SpecialCounter.Count() > MaxQueueLength) {
							atomic{AngryLeave.i{AngryPatient ++} -> Skip}
						} else {
							QueueUp.i{SpecialCounter.Add(i)} -> ((atomic{[SpecialCounter.Count()>0 && SpecialCounter.Get(0) == i]Register.i ->
							Wait[RegisterTime]; tau{SpecialCounter.RemoveAt(0)} -> Consultation(i)}) timeout[MaxWaiting] 
							(AngryLeave.i{AngryPatient ++;SpecialCounter.Remove(i)} ->Skip))
						};
							
Consultation(i) = atomic {DocotorQ.i{ConsultQueue.Add(i)} -> ([ConsultQueue.Count()>0 && ConsultQueue.Get(0) == i && FreeDoctor > 0]SeeDoctor.i{FreeDoctor=FreeDoctor-1;ConsultQueue.RemoveAt(0);} -> Wait[ConsultTime]; 
						Leave.i{FreeDoctor=FreeDoctor+1; ServePatient ++;} -> Skip;
						pcase {
						1: Inspection(i)
						3: PickMedicine(i)
						})};

Inspection(i) = atomic{InspectQ.i{InspectQueue.Add(i)} -> ([InspectQueue.Count()>0 && InspectQueue.Get(0) == i && Inspector > 0]Inspect.i{Inspector=Inspector-1;InspectQueue.RemoveAt(0);} -> Wait[ConsultTime]; 
						LeaveInspect.i{Inspector=Inspector+1;} -> Skip)};
 
PickMedicine(i) = GetMedicine.i {MedicineStock--;} -> Skip;

//Consultation(i) = (atomic {[FreeDoctor > 0]SeeDoctor.i{FreeDoctor=FreeDoctor-1;} -> Wait[ConsultTime]; 
//					Leave.i{FreeDoctor=FreeDoctor+1;} -> Skip} ) timeout[MaxWaiting] AngryLeave.i{AngryPatient ++} -> Skip;

//Patient(i) = atomic{Arrive(i);Registration(i)};

#define notEmpty NormalCounter.Count() == 0 && ServePatient > 0; 

Hospital = ||| i:{0..N-1}@Arrive(i);
#define noLeavingWithAnger  AngryPatient == 0;
#define fewLeaving 3*AngryPatient < N;
#define refillMedicine MedicineStock<StockLowerBound;
#assert Hospital deadlockfree;
//#assert Hospital reaches goal;





#assert Hospital |= [] noLeavingWithAnger with prob;
#assert Hospital |= [] fewLeaving;
#assert Hospital |= [] fewLeaving with prob;
#assert Hospital reaches refillMedicine;
#assert Hospital reaches notEmpty with prob;

HospitalWithClose = ||| i:{0..N-1}@Arrive(i) deadline[openHour];
#assert HospitalWithClose |= [] noLeavingWithAnger with prob;